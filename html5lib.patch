diff --git a/python/src/html5lib/serializer/htmlserializer.py b/python/src/html5lib/serializer/htmlserializer.py
--- a/python/src/html5lib/serializer/htmlserializer.py
+++ b/python/src/html5lib/serializer/htmlserializer.py
@@ -6,16 +6,19 @@ except NameError:
 
 import gettext
 _ = gettext.gettext
 
 from html5lib.constants import voidElements, booleanAttributes, spaceCharacters
 from html5lib.constants import rcdataElements
 
 from xml.sax.saxutils import escape
+import htmlentitydefs
+
+import re
 
 spaceCharacters = u"".join(spaceCharacters)
 
 try:
     from codecs import register_error, xmlcharrefreplace_errors
 except ImportError:
     unicode_encode_errors = "strict"
 else:
@@ -49,55 +52,78 @@ else:
 
     del register_error
 
 def encode(text, encoding):
     return text.encode(encoding, unicode_encode_errors)
 
 class HTMLSerializer(object):
 
+    # attribute quoting options
     quote_attr_values = False
     quote_char = '"'
     use_best_quote_char = True
+
+    # tag syntax options
+    omit_optional_tags = True
     minimize_boolean_attributes = True
-
     use_trailing_solidus = False
     space_before_trailing_solidus = True
+
+    # escaping options
     escape_lt_in_attrs = False
     escape_rcdata = False
+    resolve_entities = True
 
+    # miscellaneous options
+    emit_doctype = 'preserve'
     inject_meta_charset = True
     strip_whitespace = False
     sanitize = False
-    omit_optional_tags = True
 
     options = ("quote_attr_values", "quote_char", "use_best_quote_char",
           "minimize_boolean_attributes", "use_trailing_solidus",
           "space_before_trailing_solidus", "omit_optional_tags",
           "strip_whitespace", "inject_meta_charset", "escape_lt_in_attrs",
-          "escape_rcdata", 'use_trailing_solidus', "sanitize")
+          "escape_rcdata", "resolve_entities", "emit_doctype", "sanitize")
+
+    xmlEntities = ('lt', 'gt', 'amp', 'apos', 'quot')
 
     def __init__(self, **kwargs):
         """Initialize HTMLSerializer.
 
         Keyword options (default given first unless specified) include:
 
+        emit_doctype='html'|'xhtml'|'html5'|'preserve'
+          Whether to output a doctype.
+            * emit_doctype='xhtml' preserves unknown doctypes and valid
+              XHTML doctypes, converts valid HTML doctypes to their XHTML
+              counterparts, and drops <!DOCTYPE html>
+            * emit_doctype='html' preserves unknown doctypes and valid
+              HTML doctypes, converts valid XHTML doctypes to their HTML
+              counterparts, and uses <!DOCTYPE html> for missing doctypes
+            * emit_doctype='html5' Uses <!DOCTYPE html> as the doctype
+            * emit_doctype='preserve' preserves the doctype, if any, unchanged
         inject_meta_charset=True|False
           ..?
         quote_attr_values=True|False
           Whether to quote attribute values that don't require quoting
           per HTML5 parsing rules.
         quote_char=u'"'|u"'"
           Use given quote character for attribute quoting. Default is to
           use double quote unless attribute value contains a double quote,
           in which case single quotes are used instead.
         escape_lt_in_attrs=False|True
           Whether to escape < in attribute values.
         escape_rc_data=False|True
           ..?
+        resolve_entities=True|False
+          Whether to resolve named character entities that appear in the
+          source tree. The XML predified entities &lt; &gt; &amp; &quot; &apos;
+          are unaffected by this setting.
         strip_whitespace=False|True
           ..?
         minimize_boolean_attributes=True|false
           Shortens boolean attributes to give just the attribute value,
           for example <input disabled="disabled"> becomes <input disabled>.
         use_trailing_solidus
           Includes a close-tag slash at the end of the start tag of void
           elements (empty elements whose end tag is forbidden). E.g. <hr/>.
@@ -112,16 +138,96 @@ class HTMLSerializer(object):
         """
         if kwargs.has_key('quote_char'):
             self.use_best_quote_char = False
         for attr in self.options:
             setattr(self, attr, kwargs.get(attr, getattr(self, attr)))
         self.errors = []
         self.strict = False
 
+    def calc_doctype(self, token=None):
+        if self.emit_doctype == 'html5' or \
+           not token and self.emit_doctype == 'html':
+            if token:
+                return u'<!DOCTYPE html>'
+            else:
+                return u'<!DOCTYPE html>\n'
+
+        rootElement = token["name"]
+        publicID    = token["publicId"]
+        systemID    = token["systemId"]
+
+        if re.match(u'html', rootElement, re.IGNORECASE):
+            if self.emit_doctype == u'html':
+                # XHTML 1.1
+                if publicID == u"-//W3C//DTD XHTML 1.1//EN" and (not systemID \
+                or systemID == u"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"):
+                    publicID = u"-//W3C//DTD HTML 4.01//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/html4/strict.dtd"
+                # XHTML 1.0 Strict
+                elif publicID == u"-//W3C//DTD XHTML 1.0 Strict//EN" and (not systemID \
+                or systemID == u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"):
+                    publicID = u"-//W3C//DTD HTML 4.01//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/html4/strict.dtd"
+                # XHTML 1.0 Transitional
+                elif publicID == u"-//W3C//DTD XHTML 1.0 Transitional//EN" and (not systemID \
+                or systemID == u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"):
+                    publicID = u"-//W3C//DTD HTML 4.01 Transitional//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/html4/loose.dtd"
+                # XHTML 1.0 Frameset
+                elif publicID == u"-//W3C//DTD XHTML 1.0 Frameset//EN" and (not systemID \
+                or systemID == u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"):
+                    publicID = u"-//W3C//DTD HTML 4.01 Frameset//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/html4/frameset.dtd"
+            elif self.emit_doctype == u'xhtml':
+                # HTML 4.01 Strict
+                if re.match(u"-//W3C//DTD HTML 4.0(1)?//EN", publicID) and \
+                (not systemID or \
+                re.match(u"http://www.w3.org/TR/(html4|REC-html40)/strict.dtd", systemID)):
+                    publicID = u"-//W3C//DTD XHTML 1.0 Strict//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
+                # HTML4.01 Transitional
+                elif re.match(u"-//W3C//DTD HTML 4.0(1)? Transitional//EN", publicID) and \
+                (not systemID or \
+                 re.match(u"http://www.w3.org/TR/(html4|REC-html40)/loose.dtd", systemID)):
+                    publicID = u"-//W3C//DTD XHTML 1.0 Transitional//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
+                # HTML 4.01 Frameset
+                elif re.match(u"-//W3C//DTD HTML 4.0(1)? Frameset//EN", publicID) and \
+                (not systemID or \
+                 re.match(u"http://www.w3.org/TR/(html4|REC-html40)/frameset.dtd", systemID)):
+                    publicID = u"-//W3C//DTD XHTML 1.0 Frameset//EN"
+                    if systemID:
+                        systemID = u"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"
+                # HTML 3.2
+                elif re.match(u"-//W3C//DTD HTML 3.2( Final)?//EN", publicID) and not systemID:
+                    publicID = u"-//W3C//DTD XHTML 1.0 Transitional//EN"
+
+        doctype = u"<!DOCTYPE %s" % rootElement
+        if token["publicId"]:
+            doctype += u' PUBLIC "%s"' % publicID
+        elif systemID:
+            doctype += u" SYSTEM"
+        if systemID:
+            if systemID.find(u'"') >= 0:
+                if systemID.find(u"'") >= 0:
+                    self.serializeError(_("System identifer contains both single and double quote characters"))
+                quote_char = u"'"
+            else:
+                quote_char = u'"'
+            doctype += u" %s%s%s" % (quote_char, systemID, quote_char)
+        doctype += u">"
+        return doctype
+
     def serialize(self, treewalker, encoding=None):
         in_cdata = False
         self.errors = []
         if encoding and self.inject_meta_charset:
             from html5lib.filters.inject_meta_charset import Filter
             treewalker = Filter(treewalker, encoding)
         # XXX: WhitespaceFilter should be used before OptionalTagFilter
         # for maximum efficiently of this latter filter
@@ -129,36 +235,22 @@ class HTMLSerializer(object):
             from html5lib.filters.whitespace import Filter
             treewalker = Filter(treewalker)
         if self.sanitize:
             from html5lib.filters.sanitizer import Filter
             treewalker = Filter(treewalker)
         if self.omit_optional_tags:
             from html5lib.filters.optionaltags import Filter
             treewalker = Filter(treewalker)
+        posted_doctype = False
         for token in treewalker:
             type = token["type"]
             if type == "Doctype":
-                doctype = u"<!DOCTYPE %s" % token["name"]
-                
-                if token["publicId"]:
-                    doctype += u' PUBLIC "%s"' % token["publicId"]
-                elif token["systemId"]:
-                    doctype += u" SYSTEM"
-                if token["systemId"]:                
-                    if token["systemId"].find(u'"') >= 0:
-                        if token["systemId"].find(u"'") >= 0:
-                            self.serializeError(_("System identifer contains both single and double quote characters"))
-                        quote_char = u"'"
-                    else:
-                        quote_char = u'"'
-                    doctype += u" %s%s%s" % (quote_char, token["systemId"], quote_char)
-                
-                doctype += u">"
-                
+                posted_doctype = True
+                doctype = self.calc_doctype(token)
                 if encoding:
                     yield doctype.encode(encoding)
                 else:
                     yield doctype
 
             elif type in ("Characters", "SpaceCharacters"):
                 if type == "SpaceCharacters" or in_cdata:
                     if in_cdata and token["data"].find("</") >= 0:
@@ -168,25 +260,27 @@ class HTMLSerializer(object):
                     else:
                         yield token["data"]
                 elif encoding:
                     yield encode(escape(token["data"]), encoding)
                 else:
                     yield escape(token["data"])
 
             elif type in ("StartTag", "EmptyTag"):
+                if not posted_doctype:
+                    posted_doctype = True
+                    yield self.calc_doctype()
                 name = token["name"]
                 if name in rcdataElements and not self.escape_rcdata:
                     in_cdata = True
                 elif in_cdata:
                     self.serializeError(_("Unexpected child element of a CDATA element"))
                 attrs = token["data"]
                 if hasattr(attrs, "items"):
                     attrs = attrs.items()
-                attrs.sort()
                 attributes = []
                 for k,v in attrs:
                     if encoding:
                         k = k.encode(encoding, "strict")
                     attributes.append(' ')
 
                     attributes.append(k)
                     if not self.minimize_boolean_attributes or \
@@ -243,16 +337,28 @@ class HTMLSerializer(object):
                 data = token["data"]
                 if data.find("--") >= 0:
                     self.serializeError(_("Comment contains --"))
                 comment = u"<!--%s-->" % token["data"]
                 if encoding:
                     comment = comment.encode(encoding, unicode_encode_errors)
                 yield comment
 
+            elif type == "Entity":
+                name = token["name"]
+                if not htmlentitydefs.entitydefs.has_key(name):
+                    self.serializeError(_("Entity %s not recognized" % name))
+                if self.resolve_entities and name not in self.xmlEntities:
+                    data = unichr(htmlentitydefs.name2codepoint[name])
+                else:
+                    data = u"&%s;" % name
+                if encoding:
+                    data = data.encode(encoding, unicode_encode_errors)
+                yield data
+
             else:
                 self.serializeError(token["data"])
 
     def render(self, treewalker, encoding=None):
         if encoding:
             return "".join(list(self.serialize(treewalker, encoding)))
         else:
             return u"".join(list(self.serialize(treewalker)))
diff --git a/python/src/html5lib/treewalkers/_base.py b/python/src/html5lib/treewalkers/_base.py
--- a/python/src/html5lib/treewalkers/_base.py
+++ b/python/src/html5lib/treewalkers/_base.py
@@ -59,16 +59,19 @@ class TreeWalker(object):
 
     def doctype(self, name, publicId=None, systemId=None, correct=True):
         return {"type": "Doctype",
                 "name": name is not None and unicode(name) or u"",
                 "publicId": publicId,
                 "systemId": systemId,
                 "correct": correct}
 
+    def entity(self, name):
+        return {"type": "Entity", "name": unicode(name)}
+
     def unknown(self, nodeType):
         return self.error(_("Unknown node type: ") + nodeType)
 
 class RecursiveTreeWalker(TreeWalker):
     def walkChildren(self, node):
         raise NodeImplementedError
 
     def element(self, node, namespace, name, attrs, hasChildren):
@@ -84,16 +87,17 @@ class RecursiveTreeWalker(TreeWalker):
 
 from xml.dom import Node
 
 DOCUMENT = Node.DOCUMENT_NODE
 DOCTYPE = Node.DOCUMENT_TYPE_NODE
 TEXT = Node.TEXT_NODE
 ELEMENT = Node.ELEMENT_NODE
 COMMENT = Node.COMMENT_NODE
+ENTITY = Node.ENTITY_NODE
 UNKNOWN = "<#UNKNOWN#>"
 
 class NonRecursiveTreeWalker(TreeWalker):
     def getNodeDetails(self, node):
         raise NotImplementedError
     
     def getFirstChild(self, node):
         raise NotImplementedError
@@ -128,16 +132,19 @@ class NonRecursiveTreeWalker(TreeWalker)
                     hasChildren = False
                 else:
                     endTag = name
                     yield self.startTag(namespace, name, attributes)
 
             elif type == COMMENT:
                 yield self.comment(details[0])
 
+            elif type == ENTITY:
+                yield self.entity(details[0])
+
             elif type == DOCUMENT:
                 hasChildren = True
 
             else:
                 yield self.unknown(details[0])
             
             if hasChildren:
                 firstChild = self.getFirstChild(currentNode)
diff --git a/python/src/html5lib/treewalkers/lxmletree.py b/python/src/html5lib/treewalkers/lxmletree.py
--- a/python/src/html5lib/treewalkers/lxmletree.py
+++ b/python/src/html5lib/treewalkers/lxmletree.py
@@ -121,16 +121,19 @@ class TreeWalker(_base.NonRecursiveTreeW
             return _base.DOCTYPE, node.name, node.public_id, node.system_id
 
         elif isinstance(node, FragmentWrapper) and node.isstring:
             return _base.TEXT, node
 
         elif node.tag == etree.Comment:
             return _base.COMMENT, node.text
 
+        elif node.tag == etree.Entity:
+            return _base.ENTITY, node.text[1:-1] # strip &;
+
         else:
             #This is assumed to be an ordinary element
             match = tag_regexp.match(node.tag)
             if match:
                 namespace, tag = match.groups()
             else:
                 namespace = None
                 tag = node.tag
